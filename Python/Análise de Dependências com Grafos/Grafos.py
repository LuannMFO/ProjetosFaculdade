# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AnMUn95o1JYY3nafd1_3isYDyoAPo5LD
"""

# IMPORTAÇÕES PARA MANIPULÇÃO DE GRAFOS
import networkx as nx
import matplotlib.pyplot as plt

# CARREGAR ARQUIVO E CONSTRUIR O GRAFO
def carregar_dependencias(arquivo):
    grafo = nx.DiGraph()
    with open(arquivo, 'r') as f:
        for linha in f:
            partes = linha.strip().split()
            if len(partes) == 1:
                grafo.add_node(partes[0])
            elif len(partes) == 2:
                grafo.add_edge(partes[0], partes[1])
    return grafo

# VERIFICAR SE É POSSIVEL INSTALAR OS PACOTES (SE O GRAFO É ACICLICO)
def eh_instalavel(grafo):
    return nx.is_directed_acyclic_graph(grafo)

# LISTAR ORDEM DE ORDENAÇÃO (ORDENAÇÃO TOPOLOGICA)
def ordem_instalacao(grafo):
    if eh_instalavel(grafo):
        return list(nx.topological_sort(grafo))
    else:
        return None

# ENCONTRAR CICLOS (COMPONENTE CONECTADOS A MAIS DE UM PACOTE)
def encontrar_ciclos(grafo):
    scc = list(nx.strongly_connected_components(grafo))
    ciclos = [c for c in scc if len(c) > 1]
    return ciclos

# DEPENDENCIAS DIRETAS E INDIRETAS DE UM PACOTE
def dependencias_de(pacote, grafo):
    if pacote not in grafo:
        return []
    return list(nx.descendants(grafo, pacote))

# SIMULAR REMOÇÃO DE UM PACOTE E VER PACOTES AFETADOS POR ESSA REMOÇÃO
def pacotes_afetados(pacote, grafo):
    afetados = []
    for no in grafo.nodes:
        if pacote in dependencias_de(no, grafo):
            afetados.append(no)
    return afetados

# INDENTIFICAR PACOTES CRITICOS
def pacotes_criticos(grafo, top_n=5):
    dependencias = {no: len(list(nx.ancestors(grafo, no))) for no in grafo.nodes}
    return sorted(dependencias.items(), key=lambda x: x[1], reverse=True)[:top_n]
# INTERFACE DE MENU E EXECUÇÃO DAS OPCÇÕES
def menu():
    grafo = carregar_dependencias('entrada.txt')
    while True:
        print("\n--- Menu ---")
        print("1. Verificar se é possível instalar todos os pacotes")
        print("2. Mostrar ordem de instalação (ordem topológica)")
        print("3. Identificar ciclos de dependência")
        print("4. Consultar dependências de um pacote")
        print("5. Simular remoção de um pacote")
        print("6. Mostrar pacotes críticos")
        print("7. Sair")
        opcao = input("Escolha uma opção: ")

        if opcao == '1':
            if eh_instalavel(grafo):
                print("É possível instalar todos os pacotes (grafo acíclico).")
            else:
                print("Não é possível instalar todos os pacotes (ciclos encontrados).")
        elif opcao == '2':
            ordem = ordem_instalacao(grafo)
            if ordem:
                print("Ordem de instalação:", ordem)
            else:
                print("Não é possível ordenar. Existem ciclos.")
        elif opcao == '3':
            ciclos = encontrar_ciclos(grafo)
            if ciclos:
                print("Ciclos encontrados:")
                for c in ciclos:
                    print(" - ", list(c))
            else:
                print("Nenhum ciclo encontrado.")
        elif opcao == '4':
            pacote = input("Digite o nome do pacote: ")
            deps = dependencias_de(pacote, grafo)
            print(f"Dependências de {pacote}:", deps)
        elif opcao == '5':
            pacote = input("Digite o pacote a remover: ")
            afetados = pacotes_afetados(pacote, grafo)
            print(f"Pacotes afetados pela remoção de {pacote}:", afetados)
        elif opcao == '6':
            criticos = pacotes_criticos(grafo)
            print("Pacotes mais críticos (com mais dependentes):")
            for pacote, qtd in criticos:
                print(f"{pacote}: {qtd} dependentes")
        elif opcao == '7':
            break
        else:
            print("Opção inválida.")
# EXECUTAR O MENU
menu()

from google.colab import drive
drive.mount('/content/drive')